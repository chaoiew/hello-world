for /f "tokens=5" %a in ('netstat -ano ^| findstr ":8080" ^| findstr "LISTENING"') do taskkill /F /PID %a
package com.hsbc.ipe.vpms.deploy.handlers;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import org.eclipse.core.commands.AbstractHandler;
import org.eclipse.core.commands.ExecutionEvent;
import org.eclipse.core.commands.ExecutionException;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.IStatus;
import org.eclipse.core.runtime.Status;
import org.eclipse.core.runtime.jobs.Job;
import org.eclipse.jface.dialogs.MessageDialog;
import org.eclipse.swt.widgets.Shell;
import org.eclipse.ui.PlatformUI;
import org.eclipse.ui.console.ConsolePlugin;
import org.eclipse.ui.console.IConsole;
import org.eclipse.ui.console.MessageConsole;
import org.eclipse.ui.console.MessageConsoleStream;
import org.eclipse.ui.handlers.HandlerUtil;

import com.jcraft.jsch.Channel;
import com.jcraft.jsch.ChannelExec;
import com.jcraft.jsch.ChannelSftp;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.SftpException;

/**
 * 部署到远程服务器的处理程序（带输出和超时控制）
 */
public class DeployHandler extends AbstractHandler {

    // 服务器配置
    private static final String HOST = "192.168.1.3";
    private static final int PORT = 22;
    private static final String USERNAME = "root";
    private static final String PASSWORD = "root";
    
    // 文件路径配置
    private static final String LOCAL_ZIP_FILE = "c:/opt/vpms-server/models/life-models.zip";
    private static final String REMOTE_MODELS_DIR = "/opt/vpms-server/models/";
    private static final String REMOTE_START_SCRIPT = "/opt/vpms-server/start.sh";
    
    // 命令列表
    private static final String CMD_KILL_SERVER = "pkill -9 -f \"vpms-server-launch.jar\"";
    private static final String CMD_RM_MODELS_DIR = "rm -rf " + REMOTE_MODELS_DIR + "life-models";
    private static final String CMD_UNZIP = "unzip -o " + REMOTE_MODELS_DIR + "life-models.zip -d " + REMOTE_MODELS_DIR;
    private static final String CMD_START_SERVER = "sh " + REMOTE_START_SCRIPT;
    
    // 超时配置（毫秒）
    private static final long START_SERVER_TIMEOUT = 60 * 1000; // 1分钟

    @Override
    public Object execute(ExecutionEvent event) throws ExecutionException {
        Shell shell = HandlerUtil.getActiveShell(event);
        
        // 确认对话框
        if (!MessageDialog.openConfirm(shell, "确认部署", 
                "确定要部署到远程服务器吗？\n\n" +
                "服务器: " + USERNAME + "@" + HOST + ":" + PORT + "\n" +
                "本地文件: " + LOCAL_ZIP_FILE + "\n" +
                "目标目录: " + REMOTE_MODELS_DIR)) {
            return null;
        }
        
        // 创建并启动后台作业
        Job job = new Job("部署到远程服务器") {
            @Override
            protected IStatus run(IProgressMonitor monitor) {
                monitor.beginTask("准备部署...", 6); // 6个步骤
                
                MessageConsole console = findConsole("远程部署控制台");
                MessageConsoleStream out = console.newMessageStream();
                
                try {
                    out.println("开始部署到远程服务器: " + HOST);
                    out.println("=====================================");
                    
                    // 显示控制台
                    showConsole(console);
                    
                    // 检查本地文件是否存在
                    File localFile = new File(LOCAL_ZIP_FILE);
                    if (!localFile.exists()) {
                        throw new IOException("本地文件不存在: " + LOCAL_ZIP_FILE);
                    }
                    
                    // 连接到服务器
                    out.println("正在连接到服务器...");
                    try (RemoteSession session = new RemoteSession(USERNAME, HOST, PORT, PASSWORD, out)) {
                        session.connect();
                        out.println("已成功连接到服务器");
                        monitor.worked(1);
                        
                        // 步骤1: 停止服务器
                        executeCommand(session, CMD_KILL_SERVER, "停止服务器", out, monitor, -1);
                        
                        // 步骤2: 上传ZIP文件
                        uploadFile(session, localFile, REMOTE_MODELS_DIR, "上传文件", out, monitor);
                        
                        // 步骤3: 删除旧目录
                        executeCommand(session, CMD_RM_MODELS_DIR, "删除旧目录", out, monitor, -1);
                        
                        // 步骤4: 解压文件
                        executeCommand(session, CMD_UNZIP, "解压文件", out, monitor, -1);
                        
                        // 步骤5: 启动服务器（带超时控制）
                        executeCommand(session, CMD_START_SERVER, "启动服务器", out, monitor, START_SERVER_TIMEOUT);
                    }
                    
                    out.println("=====================================");
                    out.println("部署完成!");
                    return Status.OK_STATUS;
                } catch (TimeoutException e) {
                    out.println("操作超时: " + e.getMessage());
                    return new Status(IStatus.ERROR, "com.hsbc.ipe.vpms.deploy", "操作超时", e);
                } catch (Exception e) {
                    out.println("部署失败: " + e.getMessage());
                    e.printStackTrace();
                    return new Status(IStatus.ERROR, "com.hsbc.ipe.vpms.deploy", "部署失败", e);
                } finally {
                    monitor.done();
                    try {
                        out.close();
                    } catch (Exception e) {
                        // 忽略
                    }
                }
            }
        };
        
        job.setUser(true);
        job.schedule();
        
        return null;
    }
    
    /**
     * 执行远程命令（支持超时控制）
     */
    private void executeCommand(RemoteSession session, String command, String stepName, 
            MessageConsoleStream out, IProgressMonitor monitor, long timeoutMillis) throws Exception {
        
        out.println("\n[" + stepName + "] 执行命令: " + command);
        
        if (timeoutMillis > 0) {
            out.println("[" + stepName + "] 设置超时时间: " + timeoutMillis/1000 + "秒");
        }
        
        CommandResult result = session.executeCommand(command, timeoutMillis);
        
        if (!result.isSuccess()) {
            out.println("命令执行失败，退出代码: " + result.getExitCode());
            throw new Exception("命令执行失败: " + command);
        }
        
        out.println("[" + stepName + "] 命令执行成功");
        monitor.worked(1);
    }
    
    // 其他方法保持不变...
    
    /**
     * 远程会话工具类（增强版，支持输出和超时控制）
     */
    private static class RemoteSession implements AutoCloseable {
        private final String username;
        private final String host;
        private final int port;
        private final String password;
        private final MessageConsoleStream console; // 添加控制台输出
        private Session session;
        
        public RemoteSession(String username, String host, int port, String password, MessageConsoleStream console) {
            this.username = username;
            this.host = host;
            this.port = port;
            this.password = password;
            this.console = console;
        }
        
        // 其他方法保持不变...
        
        /**
         * 执行命令（支持超时和实时输出）
         */
        public CommandResult executeCommand(String command, long timeoutMillis) throws Exception {
            ChannelExec channel = null;
            Thread outputReaderThread = null;
            CountDownLatch completionLatch = new CountDownLatch(1);
            
            try {
                channel = (ChannelExec) session.openChannel("exec");
                channel.setCommand(command);
                
                // 获取命令输出流
                channel.setInputStream(null);
                channel.setErrStream(System.err);
                
                // 启动输出读取线程
                outputReaderThread = new Thread(() -> {
                    try (InputStream in = channel.getInputStream();
                         BufferedReader reader = new BufferedReader(new InputStreamReader(in))) {
                        
                        String line;
                        while ((line = reader.readLine()) != null && !Thread.currentThread().isInterrupted()) {
                            console.println(line); // 实时输出到控制台
                        }
                    } catch (Exception e) {
                        if (!Thread.currentThread().isInterrupted()) {
                            console.println("读取输出时发生错误: " + e.getMessage());
                        }
                    } finally {
                        completionLatch.countDown();
                    }
                });
                
                outputReaderThread.setDaemon(true);
                outputReaderThread.start();
                
                // 连接并执行命令
                channel.connect();
                
                // 等待命令完成或超时
                if (timeoutMillis > 0) {
                    boolean completed = completionLatch.await(timeoutMillis, TimeUnit.MILLISECONDS);
                    
                    if (!completed) {
                        // 超时处理
                        console.println("警告: 命令执行超时，正在尝试终止...");
                        
                        // 尝试优雅地关闭通道
                        if (channel != null && channel.isConnected()) {
                            channel.disconnect();
                        }
                        
                        // 中断输出读取线程
                        if (outputReaderThread != null && outputReaderThread.isAlive()) {
                            outputReaderThread.interrupt();
                        }
                        
                        throw new TimeoutException("命令执行超时: " + command);
                    }
                } else {
                    // 无限等待
                    completionLatch.await();
                }
                
                // 获取退出状态
                int exitCode = channel.getExitStatus();
                
                // 等待通道完全关闭
                while (channel.isConnected()) {
                    Thread.sleep(100);
                }
                
                return new CommandResult(exitCode, "命令执行完成，退出代码: " + exitCode);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                console.println("命令执行被中断");
                throw new Exception("命令执行被中断", e);
            } finally {
                // 确保资源被释放
                if (channel != null && channel.isConnected()) {
                    channel.disconnect();
                }
                
                if (outputReaderThread != null && outputReaderThread.isAlive()) {
                    outputReaderThread.interrupt();
                }
            }
        }
        
        // 其他方法保持不变...
    }
    
    // 其他类保持不变...
}    
